# <img src="https://coti.io/images/favicon.ico" height="32"> COTI MCP Server

[![smithery badge](https://smithery.ai/badge/@davibauer/coti-mcp)](https://smithery.ai/server/@davibauer/coti-mcp)

A Model Context Protocol (MCP) server that enables AI applications to interact with the COTI blockchain, specializing in private token operations using COTI's Multi-Party Computation (MPC) technology.

## Features

**Complete Account Management**
- Create, import, and export COTI accounts
- Switch between networks (testnet/devnet/mainnet)
- Generate AES keys and manage account credentials
- Sign messages and verify signatures
- Multi-account support with seamless switching

**Private ERC20 Token Operations**
- Deploy new private ERC20 contracts
- Comprehensive token information and allowance management
- Secure minting, transfer, and approval operations
- Balance, decimals, and supply tracking

**Private ERC721 NFT Operations**
- Deploy new private NFT collections
- Complete approval and ownership management
- Safe minting and transfer operations
- Token URI, balance, and collection supply tracking

**Transaction Management**
- Call arbitrary smart contract functions
- Monitor transaction status and retrieve logs
- Decode event data from transaction logs
- Full transaction lifecycle management

**Privacy & Encryption**
- Value encryption and decryption using COTI AES keys
- Full privacy support through MPC technology
- Secure transaction processing and message signing

## Multi-User Architecture

The COTI MCP Server now supports multiple concurrent users connecting to the same server instance with complete data isolation. Each connection maintains its own isolated session with separate account storage, ensuring that users cannot access each other's private keys, accounts, or configuration.

### Key Security Features

- **Per-Connection Session Isolation**: Each MCP connection receives a unique session ID and isolated storage
- **Private Key Protection**: Private keys, AES keys, and account data are never shared between sessions
- **Session-Scoped Configuration**: Network settings and default accounts are maintained per-session
- **Automatic Session Management**: Sessions are automatically created on connection and cleaned up on disconnect

### How It Works

When a user connects to the MCP server:

1. The MCP SDK automatically provides a unique `sessionId` for each connection
2. The server creates an isolated `SessionStorage` instance for that session
3. All tool operations (create account, import accounts, etc.) access only that session's storage
4. When the connection closes, the session and its data are automatically destroyed

### Security Implications

- **No Global State**: The server no longer uses `process.env` for storing user-specific data
- **Memory Isolation**: Each session's data is completely isolated in memory
- **Clean Separation**: Multiple users (or multiple Claude instances) can safely connect simultaneously
- **Zero Cross-Contamination**: User A creating an account is invisible to User B

### Migration Notes

If you previously configured accounts via environment variables, they will no longer be automatically available to new sessions. You will need to:

1. Use `create_account` tool to create new accounts per session, OR
2. Use `import_accounts` tool to import your existing account backup per session

Environment variables are now only used for global configuration (like default network), not for storing user-specific account data.

## Session Management & Persistence

### Understanding Sessions

Each connection to the COTI MCP server creates a unique session with isolated storage. Sessions are managed automatically by the MCP protocol:

- **Session ID**: Automatically generated by the MCP client
- **Session Lifecycle**: Active while connected, destroyed on disconnect
- **Session Data**: Stored in-memory, not persisted to disk

### Viewing Your Session Information

Use the `get_session_info` tool to see:
- Current session ID
- Number of accounts in your session
- Default account setting
- Network configuration
- All storage keys

### Session Persistence Across Restarts

**Important**: Sessions are NOT automatically persisted when you close or restart the MCP server.

To preserve your accounts across sessions:

1. **Before Disconnecting**: Use `export_accounts` to save your accounts to a JSON file
   ```
   export_accounts(file_path: "/path/to/backup.json")
   ```

2. **After Reconnecting**: Use `import_accounts` to restore your accounts
   ```
   import_accounts(
     file_path: "/path/to/backup.json",
     merge_with_existing: false
   )
   ```

3. **Quick Import**: Use `import_account_from_private_key` if you only have the private key
   ```
   import_account_from_private_key(
     private_key: "0x...",
     set_as_default: true
   )
   ```

### Session Continuation Workflow

Since the MCP SDK manages session IDs automatically, you **cannot manually specify a session ID** to "continue" a previous session. However, you can restore your session state:

```
# Session A (before disconnect)
1. create_account() or import_account_from_private_key()
2. [do work...]
3. export_accounts(file_path: "backup.json")  # Save your state

# Session B (after reconnect - NEW session ID)
1. import_accounts(file_path: "backup.json")  # Restore your state
2. [continue work...]
```

This approach gives you state persistence while maintaining security isolation between sessions.

### Best Practices

- **Always export** your accounts before closing the MCP connection
- **Use descriptive filenames** for backups (e.g., `coti-accounts-2024-01-15.json`)
- **Keep backups secure** - they contain your private keys
- **Check session info** with `get_session_info` to verify your session state
- **Set a default account** to avoid having to specify the account for each operation

## Available Tools

**Account Management (13 tools)**
- `change_default_account` - Switch between configured accounts
- `create_account` - Create new COTI account
- `decrypt_value` - Decrypt values with COTI AES key
- `encrypt_value` - Encrypt values with COTI AES key
- `export_accounts` - Export account configurations
- `generate_aes_key` - Generate new AES encryption key
- `get_current_network` - Get currently configured network
- `import_accounts` - Import account configurations from backup file
- `import_account_from_private_key` - Import account using only a private key
- `list_accounts` - List all configured accounts
- `sign_message` - Sign messages with account private key
- `switch_network` - Switch between COTI networks
- `verify_signature` - Verify message signatures

**Private ERC20 Operations (8 tools)**
- `approve_erc20_spender` - Approve spender for ERC20 tokens
- `deploy_private_erc20_contract` - Deploy new private ERC20 contract
- `get_private_erc20_allowance` - Get ERC20 token allowance
- `get_private_erc20_balance` - Get private token balance
- `get_private_erc20_decimals` - Get token decimals
- `get_private_erc20_total_supply` - Get token total supply
- `mint_private_erc20_token` - Mint private ERC20 tokens
- `transfer_private_erc20` - Transfer private ERC20 tokens

**Private ERC721 Operations (11 tools)**
- `approve_private_erc721` - Approve spender for specific NFT
- `deploy_private_erc721_contract` - Deploy new private NFT contract
- `get_private_erc721_approved` - Get approved spender for NFT
- `get_private_erc721_balance` - Get NFT balance for account
- `get_private_erc721_is_approved_for_all` - Check operator approval status
- `get_private_erc721_token_owner` - Get NFT token owner
- `get_private_erc721_token_uri` - Get NFT token URI
- `get_private_erc721_total_supply` - Get NFT collection total supply
- `mint_private_erc721_token` - Mint new private NFT
- `set_private_erc721_approval_for_all` - Set operator approval for all NFTs
- `transfer_private_erc721` - Transfer private NFTs

**Transaction Management (4 tools)**
- `call_contract_function` - Call smart contract functions
- `decode_event_data` - Decode transaction event data
- `get_transaction_logs` - Get transaction event logs
- `get_transaction_status` - Get transaction status and details

**Native Token Operations (2 tools)**
- `get_native_balance` - Get native COTI token balance
- `transfer_native` - Transfer native COTI tokens

**Session Management (1 tool)**
- `get_session_info` - Get current session ID and session state information

## Requirements

- Node.js v18 or higher
- COTI AES Key for API authentication
- COTI Private Key for signing transactions
- COTI Public Key corresponding to the private key

## Setup

### Installation

```bash
git clone https://github.com/davibauer/coti-mcp.git
cd coti-mcp
npm install
npm run dev
```

### Distribution

**Smithery**
```bash
npx -y @smithery/cli install @davibauer/coti-mcp --client claude
```

**Local Configuration**

Add to your Claude desktop configuration:

```json
{
  "mcpServers": {
    "coti-mcp": {
      "command": "node",
      "args": ["path/to/build/index.js"],
      "env": {
        "COTI_MCP_NETWORK": "testnet"
      }
    }
  }
}
```

After connecting, use the account management tools to create or import accounts:
- `create_account` - Create a new account
- `import_accounts` - Import from a backup file

**Multi-Account Support**

Each session can manage multiple accounts using the account management tools:
- Use `create_account` to create new accounts
- Use `import_accounts` to import account configurations
- Use `list_accounts` to view all accounts in your session
- Use `change_default_account` to switch between accounts

Note: Due to the new multi-user architecture, accounts are no longer configured via environment variables. Instead, accounts are managed per-session using the account management tools.

## Resources

- [COTI Documentation](https://docs.coti.io)
- [Smithery Server Page](https://smithery.ai/server/@davibauer/coti-mcp)

## License

MIT License - see LICENSE file for details.